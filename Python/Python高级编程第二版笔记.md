### 语法最佳实践
1. 在复制和遍历字典的操作中，最坏情况的复杂度n是字典曾经达到的最大元素数目，而不是当前元素数目。因此在某些情况下，如果需要频繁的遍历某个字典，那么最好创建一个新的字典，而不是仅在旧字典中删除元素。
2. Python中难以理解又非常常用的特性：迭代器（iterator），生成器（generator）， 装饰器（decorator），上下文管理器（context manager）
  * ##### 迭代器
    * 定义：迭代器只是实现了迭代器协议的容器对象。
    * 若要自己实现迭代器，需要实现\_\_next\_\_和\_\_iterator\_\_方法
  * ##### 生成器
    * 生成器提供了一种优雅的方法，可以让编写返回元素序列的函数所需的代码变得简单、高效。
    * 每次你需要返回一个序列的函数或在循环中运行的函数时，都应该考虑使用生成器。
    * 当序列元素被传递到另一个函数中以进行处理时，使用生成器的方式（相当于一次返回一个元素）可以提高整体性能。
    * 生成器是Python中协程，异步并发的基础。
  * ##### 装饰器
    * 常见的装饰器模式有如下：
        + 参数检查
        + 缓存
        + 代理
        + 上下文提供者


3. 容易被忽视的一些语法元素
  * ##### for...else...语句
      在for循环之后使用else语句，可以在循环自然结束而不是被bread语句终止时执行一个代码块。
  * ##### 函数注解
      函数注解是关于用户自定义函数使用的类型的完全可选的元信息，可以为函数定义注解，并在运行时获取这些注解。

4. 高级属性访问模式
  * 应该避免多重继承，应采用一些设计模式来替代它；
  * super使用必须一致，在类的层次结构中，要么全部使用，要么全不使用；
  * 如果代码的使用范围包括Python2，在Python3中也应该显式地继承自object；
  * 调用父类时必须查看类的层次结构。

  * ##### 描述符
    + 描述符允许你自定义在引用一个对象的属性时应该完成的事情；
    + 内部被用于实现property，方法，类方法，静态方法，和super类型；
    + 它是一个类，定义了另一个类的属性访问方式，即一个类可以将属性管理委托给另一个类；
    + ##### 描述符协议
      * 描述符协议基于三个特殊方法：\_\_get\_\_(self,obj,owner), \_\_set\_\_(self, instance, value),\_\_delete\_\_
      * 实现了\_\_get\_\_(self,obj,owner), \_\_set\_\_(self, instance, value)的描述符被称为数据描述符；只实现了\_\_get\_\_(self,obj,owner)称为非数据描述符；
      * 常用场景：数据描述符常用来校验被委托类成员数据的合法性、常用缓存被委托类的数据，多个实例共享的缓存数据等等。

### 元编程
#### 混入类
  + 混入类是一种不应该被初始化的类，而是用来向其他现有类提供某种API或者功能。
  + 混入类总是使用多种继承类添加。
### 元类
  + 所有类定义的基类都是type类；
  + 可以将某个类的元类替换为我们自定义的类型，新的元类仍然是type类的子类；
  + 用class创建的每个类都隐性的使用type作为其元类，可以通过向class语句提供metaclass关键字参数来改变这一默认行为。
  ``` python
  class ClassWithAMetaClass(metaclass=type):
      pass
  ```